<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/SIIP-Tutorial/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/SIIP-Tutorial/css/franklin.css">
  <link rel="stylesheet" href="/SIIP-Tutorial/css/basic.css">
  <link rel="icon" href="/SIIP-Tutorial/assets/favicon.png">
  <title>SIIP Tutorial</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/1.33.1/plotly.min.js" integrity="sha512-V0j9LhrK9IMNdFYZqh+IqU4cjo7wdxyHNyH+L0td4HryBuZ7Oq6QxP2/CWr6TituX31+gv5PnolvERuTbz8UNA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
      const PlotlyJS_json = async (div, url) => {
        response = await fetch(url)
        fig = await response.json()
        if (typeof fig.config === 'undefined') { fig["config"]={} }
          delete fig.layout.width
          delete fig.layout.height
          fig["layout"]["autosize"] = true
          fig["config"]["autosizable"] = true
          fig["config"]["responsive"] = true
          fig.config["scrollZoom"] = false
          delete fig.config.staticPlot
          delete fig.config.displayModeBar
          delete fig.config.doubleClick
          delete fig.config.showTips
          Plotly.newPlot(div, fig);
      }
  </script>
</head>
<body>
  <header>
  <div class="blog-name"><a href="/SIIP-Tutorial/">SIIP Tutorial</a></div>
  <nav>
    <ul>
      <li><a href="/SIIP-Tutorial/">Home</a></li>
    </ul>
    <img src="/SIIP-Tutorial/assets/hamburger.svg" id="menu-icon" />
  </nav>
</header>



<div class="franklin-content" >
  <h1 id="creating_a_system_representing_the_entire_u.s." ><a href="#creating_a_system_representing_the_entire_u.s."> Creating a <code>System</code> representing the entire U.S.</a></h1><p><strong>Originally Contributed by</strong>: Clayton Barrows</p>
<h2 id="introduction" ><a href="#introduction"> Introduction</a></h2><p>This example demonstrates how to assemble a <code>System</code> representing the entire U.S. using
<a href="https://github.com/NREL-SIIP/powersystems.jl">PowerSystems.jl</a> and the data assembled by
<a href="https://arxiv.org/abs/2002.06155">Xu, et. al.</a>. We'll use the same tabular data parsing
capability <a href="https://nbviewer.jupyter.org/github/NREL-SIIP/SIIPExamples.jl/blob/master/notebook/2_PowerSystems_examples/04_parse_tabulardata.ipynb">demonstrated on the RTS-GMLC dataset</a>.</p>
<div class="code-output"><pre><code class="code-stdout language-plaintext">  Activating project at `~/work/SIIP-Tutorial/SIIP-Tutorial/how-to/create-system-representing-united-states`
   Installed Mocking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.7.3
   Installed WeakRefStrings â”€â”€â”€â”€â”€â”€â”€â”€ v1.4.2
   Installed Tables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.7.0
   Installed JSON3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.9.3
   Installed LogExpFunctions â”€â”€â”€â”€â”€â”€â”€ v0.3.7
   Installed TimeZones â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.7.2
   Installed PowerSystems â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v1.20.0
   Installed InverseFunctions â”€â”€â”€â”€â”€â”€ v0.1.3
   Installed InfrastructureSystems â”€ v1.17.1
   Installed CSV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.10.3
    Building TimeZones â†’ `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/2d4b6de8676b34525ac518de36006dc2e89c7e2e/build.log`
Precompiling project...
[33m  âœ“ [39m[90mInverseFunctions[39m
[33m  âœ“ [39m[90mTables[39m
[33m  âœ“ [39m[90mWeakRefStrings[39m
[33m  âœ“ [39m[90mJSON3[39m
[33m  âœ“ [39m[90mMustache[39m
[33m  âœ“ [39mTimeSeries
[33m  âœ“ [39m[90mLogExpFunctions[39m
[33m  âœ“ [39m[90mPrettyTables[39m
[33m  âœ“ [39m[90mSpecialFunctions[39m
[33m  âœ“ [39m[90mDiffRules[39m
[33m  âœ“ [39mCSV
[33m  âœ“ [39m[90mForwardDiff[39m
[33m  âœ“ [39m[90mNLSolversBase[39m
[33m  âœ“ [39m[90mLineSearches[39m
[33m  âœ“ [39m[90mNLsolve[39m
[33m  âœ“ [39mDataFrames
[33m  âœ“ [39m[90mInfrastructureSystems[39m
[33m  âœ“ [39mPowerSystems
  18 dependencies successfully precompiled in 109 seconds (68 already precompiled)
  [33m18[39m dependencies precompiled but different versions are currently loaded. Restart julia to access the new versions
</code></pre></div><pre><code class="julia">using PowerSystems
using TimeSeries
using Dates
using TimeZones
using DataFrames
using CSV

abstract type AbstractOS end
abstract type Unix &lt;: AbstractOS end
abstract type BSD &lt;: Unix end

abstract type Windows &lt;: AbstractOS end
abstract type MacOS &lt;: BSD end
abstract type Linux &lt;: BSD end

if Sys.iswindows()
    const OS = Windows
elseif Sys.isapple()
    const OS = MacOS
else
    const OS = Linux
end

function unzip(::Type&lbrace;&lt;:BSD&rbrace;, filename, directory)
    @assert success(`tar -xvf $filename -C $directory`) &quot;Unable to extract $filename to $directory&quot;
end

function unzip(::Type&lbrace;Windows&rbrace;, filename, directory)
    path_7z = if Base.VERSION &lt; v&quot;0.7-&quot;
        &quot;$JULIA_HOME/7z&quot;
    else
        sep = Sys.iswindows() ? &quot;;&quot; : &quot;:&quot;
        withenv(
            &quot;PATH&quot; =&gt; string(
                joinpath(Sys.BINDIR, &quot;..&quot;, &quot;libexec&quot;),
                sep,
                Sys.BINDIR,
                sep,
                ENV[&quot;PATH&quot;],
            ),
        ) do
            Sys.which(&quot;7z&quot;)
        end
    end
    @assert success(`$path_7z x $filename -y -o$directory`) &quot;Unable to extract $filename to $directory&quot;
end</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">Main.__FRANKLIN_4456949.unzip</code></pre></div><h3 id="fetch_data" ><a href="#fetch_data"> Fetch Data</a></h3><p>PowerSystems.jl links to some test data that is suitable for this example.
Let's download the test data.</p>
<pre><code class="julia">println(&quot;downloading data...&quot;)
datadir = joinpath(Utils.path(:folder), &quot;how-to/create-system-representing-united-states/data&quot;)
siip_data = joinpath(datadir, &quot;SIIP&quot;)
if !isdir(datadir)
  mkpath(datadir)
  tempfilename = download(&quot;https://zenodo.org/record/3753177/files/USATestSystem.zip?download=1&quot;)
  unzip(OS, tempfilename, datadir)
  mkpath(siip_data)
end

config_dir = joinpath(
    joinpath(Utils.path(:folder), &quot;how-to/create-system-representing-united-states&quot;),
    &quot;config&quot;,
)</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: AssertionError: Unable to extract /tmp/jl_r8MLLP to /home/runner/work/SIIP-Tutorial/SIIP-Tutorial/how-to/create-system-representing-united-states/data
Stacktrace:
  [1] unzip(#unused#::Type{Main.__FRANKLIN_4456949.Linux}, filename::String, directory::String)
    @ Main.__FRANKLIN_4456949 ./string:25
</code></pre></div><h3 id="data_formatting" ><a href="#data_formatting"> Data Formatting</a></h3><p>This is a big dataset. Typically one would only want to include one of the interconnects
available. Lets use Texas to start. You can set <code>interconnect = nothing</code> if you want everything.</p>
<pre><code class="julia">interconnect = &quot;Texas&quot;
timezone = FixedTimeZone(&quot;UTC-6&quot;)
initial_time = ZonedDateTime(DateTime(&quot;2016-01-01T00:00:00&quot;), timezone)</code></pre>
<div class="code-output"><pre><code class="code-result language-plaintext">TimeZones.ZonedDateTime(2016, 1, 1, tz"UTC-06:00")</code></pre></div><p>There are a few minor incompatibilities between the data and the supported tabular data
format. We can resolve those here.</p>
<p>First, PowerSystems.jl only supports parsing piecewise linear generator costs from tabular
data. So, we can sample the quadratic polynomial cost curves and provide PWL points.</p>
<pre><code class="julia">println(&quot;formatting data ...&quot;)
!isnothing(interconnect) &amp;&amp; println(&quot;filtering data to include $interconnect ...&quot;)
gen = DataFrame(CSV.File(joinpath(datadir, &quot;plant.csv&quot;)))
filter!(row -&gt; row[:interconnect] == interconnect, gen)
gencost = DataFrame(CSV.File(joinpath(datadir, &quot;gencost.csv&quot;)))
gen = innerjoin(gen, gencost, on = :plant_id, makeunique = true, validate = (false, false))

function make_pwl(gen::DataFrame, traunches = 2)
    output_pct_cols = [&quot;output_point_&quot; * string(i) for i in 0:traunches]
    hr_cols = [&quot;heat_rate_incr_&quot; * string(i) for i in 1:traunches]
    pushfirst!(hr_cols, &quot;heat_rate_avg_0&quot;)
    columns =
        NamedTuple&lbrace;Tuple(Symbol.(vcat(output_pct_cols, hr_cols)))&rbrace;(repeat([Float64[]], 6))
    pwl = DataFrame(columns)
    for row in eachrow(gen)
        traunch_len = (1.0 - row.Pmin / row.Pmax) / traunches
        pct = [row.Pmin / row.Pmax + i * traunch_len for i in 0:traunches]
        #c(pct) = pct * row.Pmax * (row.GenIOB + row.GenIOC^2 + row.GenIOD^3)
        c(pct) = pct * row.Pmax * (row.c1 + row.c2^2) + row.c0 #this formats the &quot;c&quot; columns to hack the heat rate parser in PSY
        hr = [c(pct[1])]
        [push!(hr, c(pct[i + 1]) - hr[i]) for i in 1:traunches]
        push!(pwl, vcat(pct, hr))
    end
    return hcat(gen, pwl)
end

gen = make_pwl(gen);

gen[!, &quot;fuel_price&quot;] .= 1000.0;  #this formats the &quot;c&quot; columns to hack the heat rate parser in PSY</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: ArgumentError: "/home/runner/work/SIIP-Tutorial/SIIP-Tutorial/how-to/create-system-representing-united-states/data/plant.csv" is not a valid file or doesn't exist
Stacktrace:
  [1] CSV.Context(source::CSV.Arg, header::CSV.Arg, normalizenames::CSV.Arg, datarow::CSV.Arg, skipto::CSV.Arg, footerskip::CSV.Arg, transpose::CSV.Arg, comment::CSV.Arg, ignoreemptyrows::CSV.Arg, ignoreemptylines::CSV.Arg, select::CSV.Arg, drop::CSV.Arg, limit::CSV.Arg, buffer_in_memory::CSV.Arg, threaded::CSV.Arg, ntasks::CSV.Arg, tasks::CSV.Arg, rows_to_check::CSV.Arg, lines_to_check::CSV.Arg, missingstrings::CSV.Arg, missingstring::CSV.Arg, delim::CSV.Arg, ignorerepeated::CSV.Arg, quoted::CSV.Arg, quotechar::CSV.Arg, openquotechar::CSV.Arg, closequotechar::CSV.Arg, escapechar::CSV.Arg, dateformat::CSV.Arg, dateformats::CSV.Arg, decimal::CSV.Arg, truestrings::CSV.Arg, falsestrings::CSV.Arg, type::CSV.Arg, types::CSV.Arg, typemap::CSV.Arg, pool::CSV.Arg, downcast::CSV.Arg, lazystrings::CSV.Arg, stringtype::CSV.Arg, strict::CSV.Arg, silencewarnings::CSV.Arg, maxwarnings::CSV.Arg, debug::CSV.Arg, parsingdebug::CSV.Arg, validate::CSV.Arg, streaming::CSV.Arg)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/context.jl:256
  [2] #File#25
    @ ~/.julia/packages/CSV/9LsxT/src/file.jl:220 [inlined]
  [3] CSV.File(source::String)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/file.jl:220
</code></pre></div><p>There are some incomplete aspects of this dataset. Here, I've assigned some approximate
minimum up/down times, and some minor adjustments to categories. There are better
ways to do this, but this works for this script...</p>
<pre><code class="julia">gen[:, :unit_type] .= &quot;OT&quot;
gen[:, :min_up_time] .= 0.0
gen[:, :min_down_time] .= 0.0
gen[:, :ramp_30] .= gen[:, :ramp_30] ./ 30.0 # we need ramp rates in MW/min
[
    gen[gen.type .== &quot;wind&quot;, col] .= [&quot;Wind&quot;, 0.0, 0.0][ix] for
    (ix, col) in enumerate([:unit_type, :min_up_time, :min_down_time])
]
[
    gen[gen.type .== &quot;solar&quot;, col] .= [&quot;PV&quot;, 0.0, 0.0][ix] for
    (ix, col) in enumerate([:unit_type, :min_up_time, :min_down_time])
]
[
    gen[gen.type .== &quot;hydro&quot;, col] .= [&quot;HY&quot;, 0.0, 0.0][ix] for
    (ix, col) in enumerate([:unit_type, :min_up_time, :min_down_time])
]
[
    gen[gen.type .== &quot;ng&quot;, col] .= [4.5, 8][ix] for
    (ix, col) in enumerate([:min_up_time, :min_down_time])
]
[
    gen[gen.type .== &quot;coal&quot;, col] .= [24, 48][ix] for
    (ix, col) in enumerate([:min_up_time, :min_down_time])
]
[
    gen[gen.type .== &quot;nuclear&quot;, col] .= [72, 72][ix] for
    (ix, col) in enumerate([:min_up_time, :min_down_time])
]</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: UndefVarError: gen not defined
Stacktrace:
</code></pre></div><p>At the moment, PowerSimulations can't do unit commitment with generators that have Pmin = 0.0</p>
<pre><code class="julia">idx_zero_pmin = [
    g.type in [&quot;ng&quot;, &quot;coal&quot;, &quot;hydro&quot;, &quot;nuclear&quot;] &amp;&amp; g.Pmin &lt;= 0 for
    g in eachrow(gen[:, [:type, :Pmin]])
]
gen[idx_zero_pmin, :Pmin] = gen[idx_zero_pmin, :Pmax] .* 0.05

gen[:, :name] = &quot;gen&quot; .* string.(gen.plant_id)
CSV.write(joinpath(siip_data, &quot;gen.csv&quot;), gen)</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: UndefVarError: gen not defined
Stacktrace:
</code></pre></div><p>Let's also merge the zone.csv with the bus.csv and identify bus types</p>
<pre><code class="julia">bus = DataFrame(CSV.File(joinpath(datadir, &quot;bus.csv&quot;)))
!isnothing(interconnect) &amp;&amp; filter!(row -&gt; row[:interconnect] == interconnect, bus)
zone = DataFrame(CSV.File(joinpath(datadir, &quot;zone.csv&quot;)))
bus = leftjoin(bus, zone, on = :zone_id)
bustypes = Dict(1 =&gt; &quot;PV&quot;, 2 =&gt; &quot;PQ&quot;, 3 =&gt; &quot;REF&quot;, 4 =&gt; &quot;ISOLATED&quot;)
bus.bustype = [bustypes[b] for b in bus.type]
filter!(row -&gt; row[:bustype] != PowerSystems.BusTypes.ISOLATED, bus)
bus.name = &quot;bus&quot; .* string.(bus.bus_id)
CSV.write(joinpath(siip_data, &quot;bus.csv&quot;), bus)</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: ArgumentError: "/home/runner/work/SIIP-Tutorial/SIIP-Tutorial/how-to/create-system-representing-united-states/data/bus.csv" is not a valid file or doesn't exist
Stacktrace:
  [1] CSV.Context(source::CSV.Arg, header::CSV.Arg, normalizenames::CSV.Arg, datarow::CSV.Arg, skipto::CSV.Arg, footerskip::CSV.Arg, transpose::CSV.Arg, comment::CSV.Arg, ignoreemptyrows::CSV.Arg, ignoreemptylines::CSV.Arg, select::CSV.Arg, drop::CSV.Arg, limit::CSV.Arg, buffer_in_memory::CSV.Arg, threaded::CSV.Arg, ntasks::CSV.Arg, tasks::CSV.Arg, rows_to_check::CSV.Arg, lines_to_check::CSV.Arg, missingstrings::CSV.Arg, missingstring::CSV.Arg, delim::CSV.Arg, ignorerepeated::CSV.Arg, quoted::CSV.Arg, quotechar::CSV.Arg, openquotechar::CSV.Arg, closequotechar::CSV.Arg, escapechar::CSV.Arg, dateformat::CSV.Arg, dateformats::CSV.Arg, decimal::CSV.Arg, truestrings::CSV.Arg, falsestrings::CSV.Arg, type::CSV.Arg, types::CSV.Arg, typemap::CSV.Arg, pool::CSV.Arg, downcast::CSV.Arg, lazystrings::CSV.Arg, stringtype::CSV.Arg, strict::CSV.Arg, silencewarnings::CSV.Arg, maxwarnings::CSV.Arg, debug::CSV.Arg, parsingdebug::CSV.Arg, validate::CSV.Arg, streaming::CSV.Arg)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/context.jl:256
  [2] #File#25
    @ ~/.julia/packages/CSV/9LsxT/src/file.jl:220 [inlined]
  [3] CSV.File(source::String)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/file.jl:220
</code></pre></div><p>We need branch names as strings</p>
<pre><code class="julia">branch = DataFrame(CSV.File(joinpath(datadir, &quot;branch.csv&quot;)))
branch = leftjoin(
  branch,
  DataFrames.rename!(bus[:, [:bus_id, :baseKV]], [:from_bus_id, :from_baseKV]),
  on = :from_bus_id,
)
branch = leftjoin(
  branch,
  DataFrames.rename!(bus[:, [:bus_id, :baseKV]], [:to_bus_id, :to_baseKV]),
  on = :to_bus_id,
)
!isnothing(interconnect) &amp;&amp; filter!(row -&gt; row[:interconnect] == interconnect, branch)
branch.name = &quot;branch&quot; .* string.(branch.branch_id)
branch.tr_ratio = branch.from_baseKV ./ branch.to_baseKV
CSV.write(joinpath(siip_data, &quot;branch.csv&quot;), branch)</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: ArgumentError: "/home/runner/work/SIIP-Tutorial/SIIP-Tutorial/how-to/create-system-representing-united-states/data/branch.csv" is not a valid file or doesn't exist
Stacktrace:
  [1] CSV.Context(source::CSV.Arg, header::CSV.Arg, normalizenames::CSV.Arg, datarow::CSV.Arg, skipto::CSV.Arg, footerskip::CSV.Arg, transpose::CSV.Arg, comment::CSV.Arg, ignoreemptyrows::CSV.Arg, ignoreemptylines::CSV.Arg, select::CSV.Arg, drop::CSV.Arg, limit::CSV.Arg, buffer_in_memory::CSV.Arg, threaded::CSV.Arg, ntasks::CSV.Arg, tasks::CSV.Arg, rows_to_check::CSV.Arg, lines_to_check::CSV.Arg, missingstrings::CSV.Arg, missingstring::CSV.Arg, delim::CSV.Arg, ignorerepeated::CSV.Arg, quoted::CSV.Arg, quotechar::CSV.Arg, openquotechar::CSV.Arg, closequotechar::CSV.Arg, escapechar::CSV.Arg, dateformat::CSV.Arg, dateformats::CSV.Arg, decimal::CSV.Arg, truestrings::CSV.Arg, falsestrings::CSV.Arg, type::CSV.Arg, types::CSV.Arg, typemap::CSV.Arg, pool::CSV.Arg, downcast::CSV.Arg, lazystrings::CSV.Arg, stringtype::CSV.Arg, strict::CSV.Arg, silencewarnings::CSV.Arg, maxwarnings::CSV.Arg, debug::CSV.Arg, parsingdebug::CSV.Arg, validate::CSV.Arg, streaming::CSV.Arg)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/context.jl:256
  [2] #File#25
    @ ~/.julia/packages/CSV/9LsxT/src/file.jl:220 [inlined]
  [3] CSV.File(source::String)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/file.jl:220
</code></pre></div><p>The PowerSystems parser expects the files to be named a certain way.</p>
<p>And, we need a <code>control_mode</code> column in dc-line data</p>
<pre><code class="julia">dcbranch = DataFrame(CSV.File(joinpath(datadir, &quot;dcline.csv&quot;)))
!isnothing(interconnect) &amp;&amp; filter!(row -&gt; row[:from_bus_id] in bus.bus_id, dcbranch)
!isnothing(interconnect) &amp;&amp; filter!(row -&gt; row[:to_bus_id] in bus.bus_id, dcbranch)
dcbranch.name = &quot;dcbranch&quot; .* string.(dcbranch.dcline_id)
dcbranch[:, :control_mode] .= &quot;Power&quot;
CSV.write(joinpath(siip_data, &quot;dc_branch.csv&quot;), dcbranch)</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: ArgumentError: "/home/runner/work/SIIP-Tutorial/SIIP-Tutorial/how-to/create-system-representing-united-states/data/dcline.csv" is not a valid file or doesn't exist
Stacktrace:
  [1] CSV.Context(source::CSV.Arg, header::CSV.Arg, normalizenames::CSV.Arg, datarow::CSV.Arg, skipto::CSV.Arg, footerskip::CSV.Arg, transpose::CSV.Arg, comment::CSV.Arg, ignoreemptyrows::CSV.Arg, ignoreemptylines::CSV.Arg, select::CSV.Arg, drop::CSV.Arg, limit::CSV.Arg, buffer_in_memory::CSV.Arg, threaded::CSV.Arg, ntasks::CSV.Arg, tasks::CSV.Arg, rows_to_check::CSV.Arg, lines_to_check::CSV.Arg, missingstrings::CSV.Arg, missingstring::CSV.Arg, delim::CSV.Arg, ignorerepeated::CSV.Arg, quoted::CSV.Arg, quotechar::CSV.Arg, openquotechar::CSV.Arg, closequotechar::CSV.Arg, escapechar::CSV.Arg, dateformat::CSV.Arg, dateformats::CSV.Arg, decimal::CSV.Arg, truestrings::CSV.Arg, falsestrings::CSV.Arg, type::CSV.Arg, types::CSV.Arg, typemap::CSV.Arg, pool::CSV.Arg, downcast::CSV.Arg, lazystrings::CSV.Arg, stringtype::CSV.Arg, strict::CSV.Arg, silencewarnings::CSV.Arg, maxwarnings::CSV.Arg, debug::CSV.Arg, parsingdebug::CSV.Arg, validate::CSV.Arg, streaming::CSV.Arg)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/context.jl:256
  [2] #File#25
    @ ~/.julia/packages/CSV/9LsxT/src/file.jl:220 [inlined]
  [3] CSV.File(source::String)
    @ CSV ~/.julia/packages/CSV/9LsxT/src/file.jl:220
</code></pre></div><h3 id="we_need_to_create_a_reference_for_where_to_get_timeseries_data_for_each_component." ><a href="#we_need_to_create_a_reference_for_where_to_get_timeseries_data_for_each_component."> We need to create a reference for where to get timeseries data for each component.</a></h3><pre><code class="julia">timeseries = []
ts_csv = [&quot;wind&quot;, &quot;solar&quot;, &quot;hydro&quot;, &quot;demand&quot;]
plant_ids = Symbol.(string.(gen.plant_id))
for f in ts_csv
    println(&quot;formatting $f.csv ...&quot;)
    csvpath = joinpath(siip_data, f * &quot;.csv&quot;)
    csv = DataFrame(CSV.File(joinpath(datadir, f * &quot;.csv&quot;)))
    (category, name_prefix, label) =
        f == &quot;demand&quot; ? (&quot;Area&quot;, &quot;&quot;, &quot;max_active_power&quot;) :
        (&quot;Generator&quot;, &quot;gen&quot;, &quot;max_active_power&quot;)
    if !(:DateTime in names(csv))
        DataFrames.rename!(
            csv,
            (names(csv)[occursin.(&quot;UTC&quot;, String.(names(csv)))][1] =&gt; :DateTime),
        )
        #The timeseries data is in UTC, this converts it to a fixed UTC offset
        csv.DateTime =
            ZonedDateTime.(
                DateTime.(csv.DateTime, &quot;yyyy-mm-dd HH:MM:SS&quot;),
                timezone,
                from_utc = true,
            )
        delete!(csv, csv.DateTime .&lt; initial_time)
        csv.DateTime = Dates.format.(csv.DateTime, &quot;yyyy-mm-ddTHH:MM:SS&quot;)
    end
    device_names = f == &quot;demand&quot; ? unique(bus.zone_name) : gen.name
    for id in names(csv)
        colname = id
        if f == &quot;demand&quot;
            if Symbol(id) in Symbol.(zone.zone_id)
                colname = Symbol(zone[Symbol.(zone.zone_id) .== Symbol(id), :zone_name][1])
                DataFrames.rename!(csv, (id =&gt; colname))
            end
            sf = sum(bus[string.(bus.zone_id) .== id, :Pd])
        else
            if Symbol(id) in plant_ids
                colname = Symbol(gen[Symbol.(gen.plant_id) .== Symbol(id), :name][1])
                DataFrames.rename!(csv, (id =&gt; colname))
            end
            sf = maximum(csv[:, colname]) == 0.0 ? 1.0 : &quot;Max&quot;
        end
        if String(colname) in device_names
            push!(
                timeseries,
                Dict(
                    &quot;simulation&quot; =&gt; &quot;DA&quot;,
                    &quot;category&quot; =&gt; category,
                    &quot;module&quot; =&gt; &quot;InfrastructureSystems&quot;,
                    &quot;type&quot; =&gt; &quot;SingleTimeSeries&quot;,
                    &quot;component_name&quot; =&gt; String(colname),
                    &quot;name&quot; =&gt; label,
                    &quot;resolution&quot; =&gt; 3600,
                    &quot;scaling_factor_multiplier&quot; =&gt; &quot;get_max_active_power&quot;,
                    &quot;scaling_factor_multiplier_module&quot; =&gt; &quot;PowerSystems&quot;,
                    &quot;normalization_factor&quot; =&gt; sf,
                    &quot;data_file&quot; =&gt; csvpath,
                ),
            )
        end
    end
    CSV.write(csvpath, csv)
end

timeseries_pointers = joinpath(siip_data, &quot;timeseries_pointers.json&quot;)
open(timeseries_pointers, &quot;w&quot;) do io
    PowerSystems.InfrastructureSystems.JSON3.write(io, timeseries)
end</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: UndefVarError: gen not defined
Stacktrace:
</code></pre></div><p>The tabular data format relies on a folder containing <code>*.csv</code> files and <code>.yaml</code> files
describing the column names of each file in PowerSystems terms, and the PowerSystems
data type that should be created for each generator type. The respective "us<em>decriptors.yaml"
and "US</em>generator_mapping.yaml" files have already been tailored to this dataset.</p>
<pre><code class="julia">println(&quot;parsing csv files...&quot;)
rawsys = PowerSystems.PowerSystemTableData(
  siip_data,
  100.0,
  joinpath(config_dir, &quot;us_descriptors.yaml&quot;),
  generator_mapping_file = joinpath(config_dir, &quot;us_generator_mapping.yaml&quot;),
)</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: UndefVarError: config_dir not defined
Stacktrace:
</code></pre></div><h3 id="create_a_system" ><a href="#create_a_system"> Create a <code>System</code></a></h3><p>Next, we'll create a <code>System</code> from the <code>rawsys</code> data. Since a <code>System</code> is predicated on a
time series resolution and the <code>rawsys</code> data includes both 5-minute and 1-hour resolution
time series, we also need to specify which time series we want to include in the <code>System</code>.
The <code>time_series_resolution</code> kwarg filters to only include time series with a matching resolution.</p>
<pre><code class="julia">println(&quot;creating System&quot;)
sys = System(rawsys; config_path = joinpath(config_dir, &quot;us_system_validation.json&quot;));
sys</code></pre>
<div class="code-output"><pre><code class="code-stderr language-plaintext">LoadError: UndefVarError: config_dir not defined
Stacktrace:
</code></pre></div><p>This all took reasonably long, so we can save our <code>System</code> using the serialization
capability included with PowerSystems.jl:</p>
<pre><code class="julia">to_json(sys, joinpath(siip_data, &quot;sys.json&quot;), force = true)</code></pre>

  <div class="page-foot">
  <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>
  Dheepak Krishnamurthy.  Last modified: March 9, 2022. Website built with
  <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the
  <a href="https://julialang.org">Julia programming language</a>.
</div>

<script>
  var coll = document.getElementsByClassName('collapsible')
  var i

  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener('click', function () {
      this.classList.toggle('active')
      var content = this.nextElementSibling
      if (content.style.display === 'block') {
        content.style.display = 'none'
      } else {
        content.style.display = 'block'
      }
    })
  }
</script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.4.0/clipboard.min.js"></script>

<script>
  ;(function () {
    // Get the elements.
    // - the 'pre' element.
    // - the 'div' with the 'paste-content' id.

    var pre = document.getElementsByTagName('pre')

    // Add a copy button in the 'pre' element.
    // which only has the className of 'language-'.

    for (var i = 0; i < pre.length; i++) {
      var isResult = pre[i].children[0].className.indexOf('code-result')
      var isStdout = pre[i].children[0].className.indexOf('code-stdout')

      if (isResult !== 0 && isStdout !== 0) {
        var button = document.createElement('button')
        button.className = 'copy-button'
        button.textContent = 'Copy'

        pre[i].prepend(button)
      }
    }

    // Run Clipboard

    var copyCode = new Clipboard('.copy-button', {
      target: function (trigger) {
        return trigger.nextElementSibling
      },
    })

    // On success:
    // - Change the "Copy" text to "Copied".
    // - Swap it to "Copy" in 2s.
    // - Lead user to the "contenteditable" area with Velocity scroll.

    copyCode.on('success', function (event) {
      event.clearSelection()
      event.trigger.textContent = 'Copied'
      window.setTimeout(function () {
        event.trigger.textContent = 'Copy'
      }, 2000)
    })

    // On error (Safari):
    // - Change the  "Press Ctrl+C to copy"
    // - Swap it to "Copy" in 2s.

    copyCode.on('error', function (event) {
      event.trigger.textContent = 'Press "Ctrl + C" to copy'
      window.setTimeout(function () {
        event.trigger.textContent = 'Copy'
      }, 5000)
    })
  })()
</script>

</div>

    
    
        <script src="/SIIP-Tutorial/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
  </body>

</html>
